<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-06-25 Sun 12:19 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="ying dai" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script src='https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js'></script>
<link rel='stylesheet' href='../css/worg2.css' typbe='text/css'/>
<link rel='shortcut icon' type='image/x-icon' href='/favicon.ico'>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
<div id="preamble" class="status">

<div class='nav'>
<div class='blog' style='text-align:right'>
<a href='/index.html'> Home </a> | <a href='/contact.html'> Contact </a>
</div>
</div>
</div>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc8ed92e">What is a Continuous Integration System?</a></li>
<li><a href="#org4fce653">Introduction</a></li>
</ul>
</div>
</div>
<p>
A Continuous Integration System Malini Das
</p>

<p>
Malini Das is a software engineer who
is passionate about developing quickly (but safely!), and solving
cross-functional problems. She has worked at Mozilla as a tools engineer and is
currently honing her skills at Twitch. Follow Malini on Twitter or on her blog.
</p>

<div id="outline-container-orgc8ed92e" class="outline-2">
<h2 id="orgc8ed92e">What is a Continuous Integration System?</h2>
<div class="outline-text-2" id="text-orgc8ed92e">
<p>
 When developing software, we want to be able to
verify that our new features or bug fixes are safe
and work as expected. We do this by running tests
against our code. Sometimes, developers will run
tests locally to verify that their changes are
safe, but developers may not have the time to test
their code on every system their software runs in.
Further, as more and more tests are added the
amount of time required to run them, even only
locally, becomes less viable. Because of this,
continuous integration systems have been created.
</p>

<p>
Continuous Integration (CI) systems are dedicated
systems used to test new code. Upon a commit to
the code repository, it is the responsibility of
the continuous integration system to verify that
this commit will not break any tests. To do this,
the system must be able to fetch the new changes,
run the tests and report its results. Like any
other system, it should also be failure resistant.
This means if any part of the system fails, it
should be able to recover and continue from that
point.
</p>

<p>
This test system should also handle load well, so
that we can get test results in a reasonable
amount of time in the event that commits are being
made faster than the tests can be run. We can
achieve this by distributing and parallelizing the
testing effort. This project will demonstrate a
small, bare-bones distributed continuous
integration system that is designed for
extensibility.
</p>

<p>
Project Limitations and Notes
</p>

<p>
This project uses Git as the repository for the
code that needs to be tested. Only standard source
code management calls will be used, so if you are
unfamiliar with Git but are familiar with other
version control systems (VCS) like svn or
Mercurial, you can still follow along.
</p>

<p>
Due to the limitations of code length and
unittest, I simplified test discovery. We will
only run tests that are in a directory named tests
within the repository.
</p>

<p>
Continuous integration systems monitor a master
repository which is usually hosted on a web
server, and not local to the CI's file systems.
For the cases of our example, we will use a local
repository instead of a remote repository.
</p>

<p>
Continuous integration systems need not run on a
fixed, regular schedule. You can also have them
run every few commits, or per-commit. For our
example case, the CI system will run periodically.
This means if it is set up to check for changes in
five-second periods, it will run tests against the
most recent commit made after the five-second
period. It won't test every commit made within
that period of time, only the most recent one.
</p>

<p>
This CI system is designed to check periodically
for changes in a repository. In real-world CI
systems, you can also have the repository observer
get notified by a hosted repository. Github, for
example, provides "post-commit hooks" which send
out notifications to a URL. Following this model,
the repository observer would be called by the web
server hosted at that URL to respond to that
notification. Since this is complex to model
locally, we're using an observer model, where the
repository observer will check for changes instead
of being notified.
</p>

<p>
CI systems also have a reporter aspect, where the
test runner reports its results to a component
that makes them available for people to see,
perhaps on a webpage. For simplicity, this project
gathers the test results and stores them as files
in the file system local to the dispatcher
process.
</p>

<p>
Note that the architecture this CI system uses is
just one possibility among many. This approach has
been chosen to simplify our case study into three
main components.
</p>
</div>
</div>

<div id="outline-container-org4fce653" class="outline-2">
<h2 id="org4fce653">Introduction</h2>
<div class="outline-text-2" id="text-org4fce653">
<p>
The basic structure of a continuous integration
system consists of three components: an observer,
a test job dispatcher, and a test runner. The
observer watches the repository. When it notices
that a commit has been made, it notifies the job
dispatcher. The job dispatcher then finds a test
runner and gives it the commit number to test.
</p>

<p>
There are many ways to architect a CI system. We
could have the observer, dispatcher and runner be
the same process on a single machine. This
approach is very limited since there is no load
handling, so if more changes are added to the
repository than the CI system can handle, a large
backlog will accrue. This approach is also not
fault-tolerant at all; if the computer it is
running on fails or there is a power outage, there
are no fallback systems, so no tests will run. The
ideal system would be one that can handle as many
test jobs as requested, and will do its best to
compensate when machines go down.
</p>

<p>
To build a CI system that is fault-tolerant and load-bearing, in this project,
each of these components is its own process. This will let each process be
independent of the others, and let us run multiple instances of each process.
This is useful when you have more than one test job that needs to be run at the
same time. We can then spawn multiple test runners in parallel, allowing us to
run as many jobs as needed, and prevent us from accumulating a backlog of queued
tests.
</p>

<p>
In this project, not only do these components run as separate processes, but they also communicate via sockets, which will let us run each process on a separate, networked machine. A unique host/port address is assigned to each component, and each process can communicate with the others by posting messages at the assigned addresses.
</p>

<p>
This design will let us handle hardware failures on the fly by enabling a distributed architecture. We can have the observer run on one machine, the test job dispatcher on another, and the test runners on another, and they can all communicate with each other over a network. If any of these machines go down, we can schedule a new machine to go up on the network, so the system becomes fail-safe.
</p>

<p>
This project does not include auto-recovery code, as that is dependent on your distributed system's architecture, but in the real world, CI systems are run in a distributed environment like this so they can have failover redundancy (i.e., we can fall back to a standby machine if one of the machines a process was running on becomes defunct).
</p>

<p>
For the purposes of this project, each of these processes will be locally and manually started distinct local ports.
</p>

<p>
Files in this Project
This project contains Python files for each of these components: the repository observer (repo<sub>observer.py</sub>), the test job dispatcher (dispatcher.py), and the test runner (test<sub>runner.py</sub>). Each of these three processes communicate with each other using sockets, and since the code used to transmit information is shared by all of them, there is a helpers.py file that contains it, so each process imports the communicate function from here instead of having it duplicated in the file.
</p>

<p>
There are also bash script files used by these processes. These script files are used to execute bash and git commands in an easier way than constantly using Python's operating system-level modules like os and subprocess.
</p>

<p>
Lastly, there is a tests directory, which contains two example tests the CI system will run. One test will pass, and the other will fail.
</p>

<p>
Initial Setup
While this CI system is ready to work in a distributed system, let us start by running everything locally on one computer so we can get a grasp on how the CI system works without adding the risk of running into network-related issues. If you wish to run this in a distributed environment, you can run each component on its own machine.
</p>

<p>
Continuous integration systems run tests by detecting changes in a code repository, so to start, we will need to set up the repository our CI system will monitor.
</p>

<p>
Let's call this test<sub>repo</sub>:
</p>

<p>
$ mkdir test<sub>repo</sub>
$ cd test<sub>repo</sub>
$ git init
This will be our master repository. This is where developers check in their code, so our CI should pull this repository and check for commits, then run tests. The thing that checks for new commits is the repository observer.
</p>

<p>
The repository observer works by checking commits, so we need at least one commit in the master repository. Let’s commit our example tests so we have some tests to run.
</p>

<p>
Copy the tests folder from this code base to test<sub>repo</sub> and commit it:
</p>

<p>
$ cp -r <i>this/directory/tests /path/to/test<sub>repo</sub></i>
$ cd <i>path/to/test\<sub>repo</sub>
$ git add tests</i>
$ git commit -m ”add tests”
Now you have a commit in the master repository.
</p>

<p>
The repo observer component will need its own clone of the code, so it can detect when a new commit is made. Let's create a clone of our master repository, and call it test<sub>repo</sub><sub>clone</sub><sub>obs</sub>:
</p>

<p>
$ git clone /path/to/test<sub>repo</sub> test<sub>repo</sub><sub>clone</sub><sub>obs</sub>
The test runner will also need its own clone of the code, so it can checkout the repository at a given commit and run the tests. Let's create another clone of our master repository, and call it test<sub>repo</sub><sub>clone</sub><sub>runner</sub>:
</p>

<p>
$ git clone /path/to/test<sub>repo</sub> test<sub>repo</sub><sub>clone</sub><sub>runner</sub>
The Components
The Repository Observer (repo<sub>observer.py</sub>)
The repository observer monitors a repository and notifies the dispatcher when a new commit is seen. In order to work with all version control systems (since not all VCSs have built-in notification systems), this repository observer is written to periodically check the repository for new commits instead of relying on the VCS to notify it that changes have been made.
</p>

<p>
The observer will poll the repository periodically, and when a change is seen, it will tell the dispatcher the newest commit ID to run tests against. The observer checks for new commits by finding the current commit ID in its repository, then updates the repository, and lastly, it finds the latest commit ID and compares them. For the purposes of this example, the observer will only dispatch tests against the latest commit. This means that if two commits are made between a periodic check, the observer will only run tests against the latest commit. Usually, a CI system will detect all commits since the last tested commit, and will dispatch test runners for each new commit, but I have modified this assumption for simplicity.
</p>

<p>
The observer must know which repository to observe. We previously created a clone of our repository at /path/to/test<sub>repo</sub><sub>clone</sub><sub>obs</sub>. The observer will use this clone to detect changes. To allow the repository observer to use this clone, we pass it the path when we invoke the repo<sub>observer.py</sub> file. The repository observer will use this clone to pull from the main repository.
</p>

<p>
We must also give the observer the dispatcher's address, so the observer may send it messages. When you start the repository observer, you can pass in the dispatcher's server address using the &#x2013;dispatcher-server command line argument. If you do not pass it in, it will assume the default address of localhost:8888.
</p>

<p>
def poll():
    parser = argparse.ArgumentParser()
    parser.add<sub>argument</sub>("&#x2013;dispatcher-server",
                        help="dispatcher host:port, " \
                        "by default it uses localhost:8888",
                        default="localhost:8888",
                        action="store")
    parser.add<sub>argument</sub>("repo", metavar="REPO", type=str,
                        help="path to the repository this will observe")
    args = parser.parse<sub>args</sub>()
    dispatcher<sub>host</sub>, dispatcher<sub>port</sub> = args.dispatcher<sub>server.split</sub>(":")
Once the repository observer file is invoked, it starts the poll() function. This function parses the command line arguments, and then kicks off an infinite while loop. The while loop is used to periodically check the repository for changes. The first thing it does is call the update<sub>repo.sh</sub> Bash script 1.
</p>

<p>
while True:
    try:
</p>

<p>
            subprocess.check<sub>output</sub>(["./update<sub>repo.sh</sub>", args.repo])
        except subprocess.CalledProcessError as e:
            raise Exception("Could not update and check repository. " +
                            "Reason: %s" % e.output)
The update<sub>repo.sh</sub> file is used to identify any new commits and let the repository observer know. It does this by noting what commit ID we are currently aware of, then pulls the repository, and checks the latest commit ID. If they match, no changes are made, so the repository observer doesn't need to do anything, but if there is a difference in the commit ID, then we know a new commit has been made. In this case, update<sub>repo.sh</sub> will create a file called .commit<sub>id</sub> with the latest commit ID stored in it.
</p>

<p>
A step-by-step breakdown of update<sub>repo.sh</sub> is as follows. First, the script sources the run<sub>or</sub><sub>fail.sh</sub> file, which provides the run<sub>or</sub><sub>fail</sub> helper method used by all our shell scripts. This method is used to run the given command, or fail with the given error message.
</p>

<p>
#!/bin/bash
</p>

<p>
source run<sub>or</sub><sub>fail.sh</sub>
Next, the script tries to remove a file named .commit<sub>id</sub>. Since updaterepo.sh is called infinitely by the repo<sub>observer.py</sub> file, if we previously had a new commit, then .commit<sub>id</sub> was created, but holds a commit we already tested. Therefore, we want to remove that file, and create a new one only if a new commit is found.
</p>

<p>
bash rm -f .commit<sub>id</sub>
After it removes the file (if it existed), it verifies that the repository we are observing exists, and then resets it to the most recent commit, in case anything caused it to get out of sync.
</p>

<p>
run<sub>or</sub><sub>fail</sub> "Repository folder not found!" pushd $1 1&gt; /dev/null
run<sub>or</sub><sub>fail</sub> "Could not reset git" git reset &#x2013;hard HEAD
It then calls git log and parses the output, looking for the most recent commit ID.
</p>

<p>
COMMIT=$(run<sub>or</sub><sub>fail</sub> "Could not call 'git log' on repository" git log -n1)
if [ $? != 0 ]; then
  echo "Could not call 'git log' on repository"
  exit 1
fi
COMMIT<sub>ID</sub>=`echo $COMMIT | awk '{ print $2 }'`
Then it pulls the repository, getting any recent changes, then gets the most recent commit ID.
</p>

<p>
run<sub>or</sub><sub>fail</sub> "Could not pull from repository" git pull
COMMIT=$(run<sub>or</sub><sub>fail</sub> "Could not call 'git log' on repository" git log -n1)
if [ $? != 0 ]; then
  echo "Could not call 'git log' on repository"
  exit 1
fi
NEW<sub>COMMIT</sub><sub>ID</sub>=`echo $COMMIT | awk '{ print $2 }'`
Lastly, if the commit ID doesn't match the previous ID, then we know we have new commits to check, so the script stores the latest commit ID in a .commit<sub>id</sub> file.
</p>

<p>
if [ $NEW<sub>COMMIT</sub><sub>ID</sub> != $COMMIT<sub>ID</sub> ]; then
  popd 1&gt; /dev/null
  echo $NEW<sub>COMMIT</sub><sub>ID</sub> &gt; .commit<sub>id</sub>
fi
When update<sub>repo.sh</sub> finishes running in repo<sub>observer.py</sub>, the repository observer checks for the existence of the .commit<sub>id</sub> file. If the file does exist, then we know we have a new commit, and we need to notify the dispatcher so it can kick off the tests. The repository observer will check the dispatcher server's status by connecting to it and sending a 'status' request, to make sure there are no problems with it, and to make sure it is ready for instruction.
</p>

<p>
        if os.path.isfile(".commit<sub>id</sub>"):
            try:
                response = helpers.communicate(dispatcher<sub>host</sub>,
                                               int(dispatcher<sub>port</sub>),
                                               "status")
            except socket.error as e:
                raise Exception("Could not communicate with dispatcher server: %s" % e)
If it responds with "OK", then the repository observer opens the .commit<sub>id</sub> file, reads the latest commit ID and sends that ID to the dispatcher, using a dispatch:&lt;commit ID&gt; request. It will then sleep for five seconds and repeat the process. We'll also try again in five seconds if anything went wrong along the way.
</p>

<p>
            if response == "OK":
                commit = ""
                with open(".commit<sub>id</sub>", "r") as f:
                    commit = f.readline()
                response = helpers.communicate(dispatcher<sub>host</sub>,
                                               int(dispatcher<sub>port</sub>),
                                               "dispatch:%s" % commit)
                if response != "OK":
                    raise Exception("Could not dispatch the test: %s" %
                    response)
                print "dispatched!"
            else:
                raise Exception("Could not dispatch the test: %s" %
                response)
        time.sleep(5)
The repository observer will repeat this process forever, until you kill the process via a KeyboardInterrupt (Ctrl+c), or by sending it a kill signal.
</p>

<p>
The Dispatcher (dispatcher.py)
The dispatcher is a separate service used to delegate testing tasks. It listens on a port for requests from test runners and from the repository observer. It allows test runners to register themselves, and when given a commit ID from the repository observer, it will dispatch a test runner against the new commit. It also gracefully handles any problems with the test runners and will redistribute the commit ID to a new test runner if anything goes wrong.
</p>

<p>
When dispatch.py is executed, the serve function is called. First it parses the arguments that allow you to specify the dispatcher's host and port:
</p>

<p>
def serve():
    parser = argparse.ArgumentParser()
    parser.add<sub>argument</sub>("&#x2013;host",
                        help="dispatcher's host, by default it uses localhost",
                        default="localhost",
                        action="store")
    parser.add<sub>argument</sub>("&#x2013;port",
                        help="dispatcher's port, by default it uses 8888",
                        default=8888,
                        action="store")
    args = parser.parse<sub>args</sub>()
This starts the dispatcher server, and two other threads. One thread runs the runner<sub>checker</sub> function, and other runs the redistribute function.
</p>

<p>
server = ThreadingTCPServer((args.host, int(args.port)), DispatcherHandler)
print `serving on %s:%s` % (args.host, int(args.port))
</p>

<p>
&#x2026;
</p>

<p>
runner<sub>heartbeat</sub> = threading.Thread(target=runner<sub>checker</sub>, args=(server,))
redistributor = threading.Thread(target=redistribute, args=(server,))
try:
    runner<sub>heartbeat.start</sub>()
    redistributor.start()
</p>

<p>
    server.serve<sub>forever</sub>()
except (KeyboardInterrupt, Exception):
</p>

<p>
        server.dead = True
        runner<sub>heartbeat.join</sub>()
        redistributor.join()
The runner<sub>checker</sub> function periodically pings each registered test runner to make sure they are still responsive. If they become unresponsive, then that runner will be removed from the pool and its commit ID will be dispatched to the next available runner. The function will log the commit ID in the pending<sub>commits</sub> variable.
</p>

<p>
    def runner<sub>checker</sub>(server):
        def manage<sub>commit</sub><sub>lists</sub>(runner):
            for commit, assigned<sub>runner</sub> in server.dispatched<sub>commits.iteritems</sub>():
                if assigned<sub>runner</sub> == runner:
                    del server.dispatched<sub>commits</sub>[commit]
                    server.pending<sub>commits.append</sub>(commit)
                    break
            server.runners.remove(runner)
        while not server.dead:
            time.sleep(1)
            for runner in server.runners:
                s = socket.socket(socket.AF<sub>INET</sub>, socket.SOCK<sub>STREAM</sub>)
                try:
                    response = helpers.communicate(runner["host"],
                                                   int(runner["port"]),
                                                   "ping")
                    if response != "pong":
                        print "removing runner %s" % runner
                        manage<sub>commit</sub><sub>lists</sub>(runner)
                except socket.error as e:
                    manage<sub>commit</sub><sub>lists</sub>(runner)
The redistribute function is used to dispatch the commit IDs logged in pending<sub>commits</sub>. When redistribute runs, it checks if there are any commit IDs in pending<sub>commits</sub>. If so, it calls the dispatch<sub>tests</sub> function with the commit ID.
</p>

<p>
    def redistribute(server):
        while not server.dead:
            for commit in server.pending<sub>commits</sub>:
                print "running redistribute"
                print server.pending<sub>commits</sub>
                dispatch<sub>tests</sub>(server, commit)
                time.sleep(5)
The dispatch<sub>tests</sub> function is used to find an available test runner from the pool of registered runners. If one is available, it will send a runtest message to it with the commit ID. If none are currently available, it will wait two seconds and repeat this process. Once dispatched, it logs which commit ID is being tested by which test runner in the dispatched<sub>commits</sub> variable. If the commit ID is in the pending<sub>commits</sub> variable, dispatch<sub>tests</sub> will remove it since it has already been successfully re-dispatched.
</p>

<p>
def dispatch<sub>tests</sub>(server, commit<sub>id</sub>):
</p>

<p>
    while True:
        print "trying to dispatch to runners"
        for runner in server.runners:
            response = helpers.communicate(runner["host"],
                                           int(runner["port"]),
                                           "runtest:%s" % commit<sub>id</sub>)
            if response == "OK":
                print "adding id %s" % commit<sub>id</sub>
                server.dispatched<sub>commits</sub>[commit<sub>id</sub>] = runner
                if commit<sub>id</sub> in server.pending<sub>commits</sub>:
                    server.pending<sub>commits.remove</sub>(commit<sub>id</sub>)
                return
        time.sleep(2)
The dispatcher server uses the SocketServer module, which is a very simple server that is part of the standard library. There are four basic server types in the SocketServer module: TCP, UDP, UnixStreamServer and UnixDatagramServer. We will be using a TCP-based socket server so we can ensure continuous, ordered streams of data between servers, as UDP does not ensure this.
</p>

<p>
The default TCPServer provided by SocketServer can only handle one request at a time, so it cannot handle the case where the dispatcher is talking to one connection, say from a test runner, and then a new connection comes in, say from the repository observer. If this happens, the repository observer would have to wait for the first connection to complete and disconnect before it would be serviced. This is not ideal for our case, since the dispatcher server must be able to directly and swiftly communicate with all test runners and the repository observer.
</p>

<p>
In order for the dispatcher server to handle simultaneous connections, it uses the ThreadingTCPServer custom class, which adds threading ability to the default SocketServer. This means that any time the dispatcher receives a connection request, it spins off a new process just for that connection. This allows the dispatcher to handle multiple requests at the same time.
</p>

<p>
class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    runners = [] # Keeps track of test runner pool
    dead = False # Indicate to other threads that we are no longer running
    dispatched<sub>commits</sub> = {} # Keeps track of commits we dispatched
    pending<sub>commits</sub> = [] # Keeps track of commits we have yet to dispatch
The dispatcher server works by defining handlers for each request. This is defined by the DispatcherHandler class, which inherits from SocketServer's BaseRequestHandler. This base class just needs us to define the handle function, which will be invoked whenever a connection is requested. The handle function defined in DispatcherHandler is our custom handler, and it will be called on each connection. It looks at the incoming connection request (self.request holds the request information), and parses out what command is being requested of it.
</p>

<p>
class DispatcherHandler(SocketServer.BaseRequestHandler):
    """
    The RequestHandler class for our dispatcher.
    This will dispatch test runners against the incoming commit
    and handle their requests and test results
    """
    command<sub>re</sub> = re.compile(r"(\w+)(:.+)*")
    BUF<sub>SIZE</sub> = 1024
    def handle(self):
        self.data = self.request.recv(self.BUF<sub>SIZE</sub>).strip()
        command<sub>groups</sub> = self.command<sub>re.match</sub>(self.data)
        if not command<sub>groups</sub>:
            self.request.sendall("Invalid command")
            return
        command = command<sub>groups.group</sub>(1)
It handles four commands: status, register, dispatch, and results. status is used to check if the dispatcher server is up and running.
</p>

<p>
        if command == "status":
            print "in status"
            self.request.sendall("OK")
In order for the dispatcher to do anything useful, it needs to have at least one test runner registered. When register is called on a host:port pair, it stores the runner's information in a list (the runners object attached to the ThreadingTCPServer object) so it can communicate with the runner later, when it needs to give it a commit ID to run tests against.
</p>

<p>
elif command == "register":
</p>

<p>
            print "register"
            address = command<sub>groups.group</sub>(2)
            host, port = re.findall(r":(\w*)", address)
            runner = {"host": host, "port":port}
            self.server.runners.append(runner)
            self.request.sendall("OK")
dispatch is used by the repository observer to dispatch a test runner against a commit. The format of this command is dispatch:&lt;commit ID&gt;. The dispatcher parses out the commit ID from this message and sends it to the test runner.
</p>

<p>
elif command == "dispatch":
    print "going to dispatch"
    commit<sub>id</sub> = command<sub>groups.group</sub>(2)[1:]
    if not self.server.runners:
        self.request.sendall("No runners are registered")
    else:
</p>

<p>
                self.request.sendall("OK")
                dispatch<sub>tests</sub>(self.server, commit<sub>id</sub>)
results is used by a test runner to report the results of a finished test run. The format of this command is results:&lt;commit ID&gt;:&lt;length of results data in bytes&gt;:&lt;results&gt;. The &lt;commit ID&gt; is used to identify which commit ID the tests were run against. The &lt;length of results data in bytes&gt; is used to figure out how big a buffer is needed for the results data. Lastly, &lt;results&gt; holds the actual result output.
</p>

<p>
elif command == "results":
    print "got test results"
    results = command<sub>groups.group</sub>(2)[1:]
    results = results.split(":")
    commit<sub>id</sub> = results[0]
    length<sub>msg</sub> = int(results[1])
</p>

<p>
            remaining<sub>buffer</sub> = self.BUF<sub>SIZE</sub> - \
                (len(command) + len(commit<sub>id</sub>) + len(results[1]) + 3)
            if length<sub>msg</sub> &gt; remaining<sub>buffer</sub>:
                self.data += self.request.recv(length<sub>msg</sub> - remaining<sub>buffer</sub>).strip()
            del self.server.dispatched<sub>commits</sub>[commit<sub>id</sub>]
            if not os.path.exists("test<sub>results</sub>"):
                os.makedirs("test<sub>results</sub>")
            with open("test<sub>results</sub>/%s" % commit<sub>id</sub>, "w") as f:
                data = self.data.split(":")[3:]
                data = "\n".join(data)
                f.write(data)
            self.request.sendall("OK")
The Test Runner (test<sub>runner.py</sub>)
The test runner is responsible for running tests against a given commit ID and reporting the results. It communicates only with the dispatcher server, which is responsible for giving it the commit IDs to run against, and which will receive the test results.
</p>

<p>
When the test<sub>runner.py</sub> file is invoked, it calls the serve function which starts the test runner server, and also starts a thread to run the dispatcher<sub>checker</sub> function. Since this startup process is very similar to the ones described in repo<sub>observer.py</sub> and dispatcher.py, we omit the description here.
</p>

<p>
The dispatcher<sub>checker</sub> function pings the dispatcher server every five seconds to make sure it is still up and running. This is important for resource management. If the dispatcher goes down, then the test runner will shut down since it won't be able to do any meaningful work if there is no dispatcher to give it work or to report to.
</p>

<p>
    def dispatcher<sub>checker</sub>(server):
        while not server.dead:
            time.sleep(5)
            if (time.time() - server.last<sub>communication</sub>) &gt; 10:
                try:
                    response = helpers.communicate(
                                       server.dispatcher<sub>server</sub>["host"],
                                       int(server.dispatcher<sub>server</sub>["port"]),
                                       "status")
                    if response != "OK":
                        print "Dispatcher is no longer functional"
                        server.shutdown()
                        return
                except socket.error as e:
                    print "Can't communicate with dispatcher: %s" % e
                    server.shutdown()
                    return
The test runner is a ThreadingTCPServer, like the dispatcher server. It requires threading because not only will the dispatcher be giving it a commit ID to run, but the dispatcher will be pinging the runner periodically to verify that it is still up while it is running tests.
</p>

<p>
class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    dispatcher<sub>server</sub> = None # Holds the dispatcher server host/port information
    last<sub>communication</sub> = None # Keeps track of last communication from dispatcher
    busy = False # Status flag
    dead = False # Status flag
The communication flow starts with the dispatcher requesting that the runner accept a commit ID to run. If the test runner is ready to run the job, it responds with an acknowledgement to the dispatcher server, which then closes the connection. In order for the test runner server to both run tests and accept more requests from the dispatcher, it starts the requested test job on a new thread.
</p>

<p>
This means that when the dispatcher server makes a request (a ping, in this case) and expects a response, it will be done on a separate thread, while the test runner is busy running tests on its own thread. This allows the test runner server to handle multiple tasks simultaneously. Instead of this threaded design, it is possible to have the dispatcher server hold onto a connection with each test runner, but this would increase the dispatcher server's memory needs, and is vulnerable to network problems, like accidentally dropped connections.
</p>

<p>
The test runner server responds to two messages from the dispatcher. The first is ping, which is used by the dispatcher server to verify that the runner is still active.
</p>

<p>
class TestHandler(SocketServer.BaseRequestHandler):
    &#x2026;
</p>

<p>
    def handle(self):
        &#x2026;.
        if command == "ping":
            print "pinged"
            self.server.last<sub>communication</sub> = time.time()
            self.request.sendall("pong")
The second is runtest, which accepts messages of the form runtest:&lt;commit ID&gt;, and is used to kick off tests on the given commit. When runtest is called, the test runner will check to see if it is already running a test, and if so, it will return a BUSY response to the dispatcher. If it is available, it will respond to the server with an OK message, set its status as busy and run its run<sub>tests</sub> function.
</p>

<p>
        elif command == "runtest":
            print "got runtest command: am I busy? %s" % self.server.busy
            if self.server.busy:
                self.request.sendall("BUSY")
            else:
                self.request.sendall("OK")
                print "running"
                commit<sub>id</sub> = command<sub>groups.group</sub>(2)[1:]
                self.server.busy = True
                self.run<sub>tests</sub>(commit<sub>id</sub>,
                               self.server.repo<sub>folder</sub>)
                self.server.busy = False
This function calls the shell script test<sub>runner</sub><sub>script.sh</sub>, which updates the repository to the given commit ID. Once the script returns, if it was successful at updating the repository we run the tests using unittest and gather the results in a file. When the tests have finished running, the test runner reads in the results file and sends it in a results message to the dispatcher.
</p>

<p>
def run<sub>tests</sub>(self, commit<sub>id</sub>, repo<sub>folder</sub>):
</p>

<p>
output = subprocess.check<sub>output</sub>(["./test<sub>runner</sub><sub>script.sh</sub>",
                                repo<sub>folder</sub>, commit<sub>id</sub>])
print output
</p>

<p>
test<sub>folder</sub> = os.path.join(repo<sub>folder</sub>, "tests")
suite = unittest.TestLoader().discover(test<sub>folder</sub>)
result<sub>file</sub> = open("results", "w")
unittest.TextTestRunner(result<sub>file</sub>).run(suite)
result<sub>file.close</sub>()
result<sub>file</sub> = open("results", "r")
</p>

<p>
        output = result<sub>file.read</sub>()
        helpers.communicate(self.server.dispatcher<sub>server</sub>["host"],
                            int(self.server.dispatcher<sub>server</sub>["port"]),
                            "results:%s:%s:%s" % (commit<sub>id</sub>, len(output), output))
Here's test<sub>runner</sub><sub>script.sh</sub>:
</p>

<p>
#!/bin/bash
REPO=$1
COMMIT=$2
source run<sub>or</sub><sub>fail.sh</sub>
run<sub>or</sub><sub>fail</sub> "Repository folder not found" pushd "$REPO" 1&gt; /dev/null
run<sub>or</sub><sub>fail</sub> "Could not clean repository" git clean -d -f -x
run<sub>or</sub><sub>fail</sub> "Could not call git pull" git pull
run<sub>or</sub><sub>fail</sub> "Could not update to given commit hash" git reset &#x2013;hard "$COMMIT"
In order to run test<sub>runner.py</sub>, you must point it to a clone of the repository to run tests against. In this case, you can use the previously created /path/to/test<sub>repo</sub> test<sub>repo</sub><sub>clone</sub><sub>runner</sub> clone as the argument. By default, test<sub>runner.py</sub> will start its own server on localhost using a port in the range 8900-9000, and will try to connect to the dispatcher server at localhost:8888. You may pass it optional arguments to change these values. The &#x2013;host and &#x2013;port arguments are used to designate a specific address to run the test runner server on, and the &#x2013;dispatcher-server argument specifies the address of the dispatcher.
</p>

<p>
Control Flow Diagram
</p>

<p>
Figure 2.1 is an overview diagram of this system.
This diagram assumes that all three files
(repo<sub>observer.py</sub>, dispatcher.py and
test<sub>runner.py</sub>) are already running, and describes
the actions each process takes when a new commit
is made.
</p>

<p>
Figure 2.1 - Control Flow
Figure 2.1 - Control Flow
</p>

<p>
Running the Code
We can run this simple CI system locally, using three different terminal shells for each process. We start the dispatcher first, running on port 8888:
</p>

<p>
$ python dispatcher.py
In a new shell, we start the test runner (so it can register itself with the dispatcher):
</p>

<p>
$ python test<sub>runner.py</sub> &lt;path/to/test<sub>repo</sub><sub>clone</sub><sub>runner</sub>&gt;
The test runner will assign itself its own port, in the range 8900-9000. You may run as many test runners as you like.
</p>

<p>
Lastly, in another new shell, let's start the repo observer:
</p>

<p>
$ python repo<sub>observer.py</sub> &#x2013;dispatcher-server=localhost:8888 &lt;path/to/repo<sub>clone</sub><sub>obs</sub>&gt;
Now that everything is set up, let's trigger some tests! To do that, we'll need to make a new commit. Go to your master repository and make an arbitrary change:
</p>

<p>
$ cd /path/to/test<sub>repo</sub>
$ touch new<sub>file</sub>
$ git add new<sub>file</sub>
$ git commit -m"new file" new<sub>file</sub>
Then repo<sub>observer.py</sub> will realize that there's a new commit and notify the dispatcher. You can see the output in their respective shells, so you can monitor them. Once the dispatcher receives the test results, it stores them in a test<sub>results</sub>/ folder in this code base, using the commit ID as the filename.
</p>

<p>
Error Handling
This CI system includes some simple error handling.
</p>

<p>
If you kill the test<sub>runner.py</sub> process, dispatcher.py will figure out that the runner is no longer available and will remove it from the pool.
</p>

<p>
You can also kill the test runner, to simulate a machine crash or network failure. If you do so, the dispatcher will realize the runner went down and will give another test runner the job if one is available in the pool, or will wait for a new test runner to register itself in the pool.
</p>

<p>
If you kill the dispatcher, the repository observer will figure out it went down and will throw an exception. The test runners will also notice, and shut down.
</p>

<p>
Conclusion By separating concerns into their own
processes, we were able to build the fundamentals
of a distributed continuous integration system.
With processes communicating with each other via
socket requests, we are able to distribute the
system across multiple machines, helping to make
our system more reliable and scalable.
</p>

<p>
Since the CI system is quite simple now, you can
extend it yourself to be far more functional. Here
are a few suggestions for improvements:
</p>

<p>
Per-Commit Test Runs
</p>

<p>
The current system will periodically check to see
if new commits are run and will run the most
recent commit. This should be improved to test
each commit. To do this, you can modify the
periodic checker to dispatch test runs for each
commit in the log between the last-tested and the
latest commit.
</p>

<p>
Smarter Test Runners
</p>

<p>
If the test runner detects that the dispatcher is
unresponsive, it stops running. This happens even
when the test runner is in the middle of running
tests! It would be better if the test runner
waited for a period of time (or indefinitely, if
you do not care about resource management) for the
dispatcher to come back online. In this case, if
the dispatcher goes down while the test runner is
actively running a test, instead of shutting down
it will complete the test and wait for the
dispatcher to come back online, and will report
the results to it. This will ensure that we don't
waste any effort the test runner makes, and that
we will only run tests once per commit.
</p>

<p>
Real Reporting
</p>

<p>
In a real CI system, you would have
the test results report to a reporter service
which would gather the results, post them
somewhere for people to review, and notify a list
of interested parties when a failure or other
notable event occurs. You can extend our simple CI
system by creating a new process to get the
reported results, instead of the dispatcher
gathering the results. This new process could be a
web server (or can connect to a web server) which
could post the results online, and may use a mail
server to alert subscribers to any test failures.
</p>

<p>
Test Runner Manager
Right now, you have to
manually launch the test<sub>runner.py</sub> file to start a
test runner. Instead, you could create a test
runner manager process which would assess the
current load of test requests from the dispatcher
and scale the number of active test runners
accordingly. This process will receive the runtest
messages and will start a test runner process for
each request, and will kill unused processes when
the load decreases.
</p>


<p>
Using these suggestions, you can make this simple
CI system more robust and fault-tolerant, and you
can integrate it with other systems, like a
web-based test reporter.
</p>

<p>
If you wish to see the level of flexibility
continuous integration systems can achieve, I
recommend looking into Jenkins, a very robust,
open-source CI system written in Java. It provides
you with a basic CI system which you can extend
using plugins. You may also access its source code
through GitHub. Another recommended project is
Travis CI, which is written in Ruby and whose
source code is also available through GitHub.
</p>

<p>
This has been an exercise in understanding how CI
systems work, and how to build one yourself. You
should now have a more solid understanding of what
is needed to make a reliable distributed system,
and you can now use this knowledge to develop more
complex solutions.
</p>

<p>
Bash is used because we need to check file
existence, create files, and use Git, and a shell
script is the most direct and easy way to achieve
this. Alternatively, there are cross-platform
Python packages you can use; for example, Python's
os built-in module can be used for accessing the
file system, and GitPython can be used for Git
access, but they perform actions in a more
roundabout way.↩
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/datejs/1.0/date.min.js"></script>

<script>
var base_url = 'https://api.github.com';
var title = document.title;
var owner = 'yydai';
var repo = 'yydai.github.io';
var search_issues = base_url + '/search/issues?q=' + title + '+user:' + owner + '+label:blog'+ '+state:open';

console.log("search_issues = "+ search_issues);

function test() {
  jQuery.ajax({
      type: 'GET',
      async: false,
      dataType:'json',
      url: search_issues,
      success:function(data) {
         result = data;
      }
  });
  return result;
}
var result = test();
var items = result.items[0];
if(jQuery.isEmptyObject(items)) {
    create(title);
} else {
    html_url = items.html_url;
	document.body.innerHTML +=
'<div id="comments"><h2>Comments</h2><div id="header">Want to leave a comment? Visit <a href="'+ html_url + '"> this issue page on GitHub</a> (you will need a GitHub account).</div></div>'
}


function create(title) {
	var create_url = 'https://blog-api-server.herokuapp.com/issues?title=' + title + '&labels=blog&body=Welcome to leave comments here.&owner=yydai&repo=yydai.github.io'

	jQuery.ajax({
      type: 'GET',
      async: false,
      dataType:'json',
      url: create_url,
      success:function(data) {
         result = data;
      }
  });
}


console.log("total_count = " + result.total_count);
if(result.total_count == 1) {
    var comments_url = result.items[0].comments_url;
} else if (result.total_count == 0) {
        // create a new issue
    //create(title);
} else {
        // result not only
        alert('Cannot load the comments.');
}

function loadComments(data) {
    for (var i=0; i<data.length; i++) {
      var cuser = data[i].user.login;
      var cuserlink = 'https://' + repo + '/' + data[i].user.login;
      var clink = comments_url + '#issuecomment-' + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var cbody = data[i].body_html;
      var cavatarlink = data[i].user.avatar_url;
      var cdate = Date.parse(data[i].created_at).toString('yyyy-MM-dd HH:mm:ss');

      var code = '<div class="comment"><div class="commentheader"><div class="commentgravatar">' + '<img src="' + cavatarlink + '" alt="" width="20" height="20">' + '</div><a class="commentuser" href=\""+ cuserlink + "\">' + cuser + '</a><a class="commentdate" href=\"" + clink + "\">' + cdate + '</a></div><div class="commentbody">' + cbody + '</div></div>';

      $('#comments').append(code);
    }
  }


var comments_api = comments_url + '?per_page=100';
console.log("comments api: " + comments_api);
$.ajax(comments_api, {
    headers: {Accept: 'application/vnd.github.full+json'},
    dataType: 'json',
    success: function(msg){
      loadComments(msg);
   }
  });


</script>

<hr />
 <div class='footer'>
© 2017 yydai<br/>
Email: dai92817@icloud.com
</div>
</div>
</body>
</html>
